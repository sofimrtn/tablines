package es.ctic.tabels

import scala.collection.mutable.ListBuffer
import grizzled.slf4j.Logging
import es.ctic.tabels.CommonNamespaces._
import es.ctic.tabels.TripleTemplate._   // implicit conversions

trait Autogenerator extends Logging {

    val prefixes = Seq(("ex", EX()))

    def autogenerateProgram(dataSource : DataSource) : S

    protected def hasHeaderRow(dataSource : DataSource, filename : String, sheet : String) : Boolean = {
        val firstRow = dataSource.getRow(filename, sheet, 0)
        val secondRow = dataSource.getRow(filename, sheet, 1)
        val firstRowFormats = firstRow map (_.rdfType)
        val secondRowFormats = secondRow map (_.rdfType)
        val differentFormatsCount = firstRowFormats zip secondRowFormats count { case (x,y) => !(x == y) }
        logger.debug("Different formats in " + differentFormatsCount + " cols")
        return differentFormatsCount > 0
    }
    
    protected def literalToLocalName(literal : Literal) : Option[String] = Some(literal.value.toString.replaceAll("[^a-zA-Z0-9_]","")) // FIXME: normalize value
    
    protected def literalsToUniqueLocalNames(literals : Seq[Literal], prefix : String) : Seq[String] =
        literals.map(literalToLocalName _).zipWithIndex.map {
            case (None,i) => prefix + i.toString
            case (Some(ln),_) => ln
        } // FIXME: make sure they're unique
    
}

class BasicAutogenerator extends Autogenerator with Logging {

    override def autogenerateProgram(dataSource : DataSource) : S = {
        val statements = new ListBuffer[TabelsStatement]
        val tripleTemplates = new ListBuffer[TripleTemplate]
        val filename = dataSource.filenames(0)
        val sheet = dataSource.getTabs(filename)(0)
        logger.info("Autogenerating Tabels program for file " + filename + ", sheet " + sheet)
        
        val hasHeader = hasHeaderRow(dataSource, filename, sheet)
        lazy val headerRow = dataSource.getRow(filename, sheet, 0)
        val cols = dataSource.getCols(filename, sheet)
        val variables : Seq[Variable] =
            if (hasHeader) (literalsToUniqueLocalNames(headerRow, "v") map (ln => Variable("?" + ln)))
            else for (col <- List.range(1, cols+1)) yield Variable("?v" + col)
        val properties : Seq[Resource] =
            if (hasHeader) (literalsToUniqueLocalNames(headerRow, "prop") map (ln => EX(ln)))
            else for (col <- List.range(1, cols+1)) yield EX("attr" + col)
        val tuple = Tuple(variables)
        val resource = Variable("?resource")
        val rowId = Variable("?rowId")
        
        val matchStmt = MatchStatement(tuple)
        val letStmt = LetStatement(resource, ResourceExpression(VariableReference(rowId), EX()), Some(matchStmt))
        val forStmt = IteratorStatement(Dimension.rows, variable = Some(rowId), filter = if (hasHeader) Some(VariableReference(rowId)) else None, nestedStatement = Some(letStmt))
        val inSheetStmt = SetInDimensionStatement(Dimension.sheets, fixedDimension = sheet, nestedStatement = Some(forStmt))
        val inFileStmt = SetInDimensionStatement(Dimension.files, fixedDimension = filename, nestedStatement = Some(inSheetStmt))
        statements += inFileStmt
        
        tripleTemplates += TripleTemplate(resource, RDF_TYPE, EX("SomeResource"))
        tripleTemplates ++= properties zip variables map { case (p,v) => TripleTemplate(resource, p, v) }
        val template = Template(tripleTemplates)
        val templates = List(template)
        
        val program = S(prefixes, statements, templates)
        logger.info("Autogenerated Tabels program: " + program)
        return program
    }
    
}

class ScovoAutogenerator extends Autogenerator with Logging {
    
    override val prefixes = Seq(("ex", EX()), ("scv", SCV()), ("rdf", RDF()), ("rdfs", RDFS()), ("skos", SKOS()))
    
    override def autogenerateProgram(dataSource : DataSource) : S = {
        val filename = dataSource.filenames(0)
        val sheet = dataSource.getTabs(filename)(0)
        logger.info("Autogenerating Tabels program for file " + filename + ", sheet " + sheet)
        
        val cols = dataSource.getCols(filename, sheet)

        val itemValue = Variable("?itemValue")
        val item = Variable("?item")
        val rowId = Variable("?rowId")
        val dataset = EX("myDataset")

        // dimensions
        val dimensionLabelVars : List[Variable] = for (col <- List.range(1, cols)) yield Variable("?dl" + col)
        val headerTuple = Tuple(dimensionLabelVars)
        val dimensionVars : List[Variable] = for (col <- List.range(1, cols)) yield Variable("?d" + col)

        // dimension values
        val dimensionValueLabelsVars : List[Variable] = for (col <- List.range(1, cols)) yield Variable("?dvl" + col)
        val rowTuple = Tuple(dimensionValueLabelsVars :+ itemValue)
        val dimensionValueVars : List[Variable] = for (col <- List.range(1, cols)) yield Variable("?dv" + col)        
        
        val terminalStmt : Option[TabelsStatement] = None
        val letDimensionValues : Option[TabelsStatement] = List.range(0, cols-1).foldLeft(terminalStmt)(
            (innerStmt, i) => Some(LetStatement(dimensionValueVars(i),
                                                ResourceExpression(VariableReference(dimensionValueLabelsVars(i)), EX()),
                                                nestedStatement = innerStmt))
        )
        
        val matchRowStmt = MatchStatement(rowTuple, nestedStatement = letDimensionValues)
        val letItemStmt = LetStatement(item, ResourceExpression(GetRowExpression(rowId), EX()), Some(matchRowStmt))
        val forStmt : TabelsStatement = IteratorStatement(Dimension.rows, variable = Some(rowId),
            filter = Some(GetRowExpression(rowId)), nestedStatement = Some(letItemStmt))
        
        val letDimensions : TabelsStatement = List.range(0, cols-1).foldLeft(forStmt)(
            (innerStmt, i) => LetStatement(dimensionVars(i),
                                           ResourceExpression(VariableReference(dimensionLabelVars(i)), EX()),
                                           nestedStatement = Some(innerStmt))
        )
        
        val matchHeadersStmt = MatchStatement(headerTuple, position = Some(FixedPosition(row = 0, col = 0)), nestedStatement = Some(letDimensions))
        val inSheetStmt = SetInDimensionStatement(Dimension.sheets, fixedDimension = sheet, nestedStatement = Some(matchHeadersStmt))
        val inFileStmt = SetInDimensionStatement(Dimension.files, fixedDimension = filename, nestedStatement = Some(inSheetStmt))

        val templates = new ListBuffer[Template]

        val itemTripleTemplates = new ListBuffer[TripleTemplate]
        itemTripleTemplates ++= List(
            (item, RDF_TYPE, SCV("Item")),
            (item, SCV("dataset"), dataset),
            (item, RDF("value"), itemValue)
        )
        itemTripleTemplates ++= (dimensionValueVars map (TripleTemplate(item, SCV("dimension"), _)))
        templates += Template(itemTripleTemplates)
        
        templates ++= (for (dim <- List.range(0, cols-1)) yield Template(List(
            (dimensionValueVars(dim), RDF_TYPE, dimensionVars(dim)),
            (dimensionValueVars(dim), SKOS("prefLabel"), dimensionValueLabelsVars(dim)),
            (dimensionVars(dim), RDFS("subClassOf"), SCV("Dimension")),
            (dimensionVars(dim), SKOS("prefLabel"), dimensionLabelVars(dim))
        )))
        
        templates += Template(List(
            (dataset, RDF_TYPE, SCV("Dataset")),
            (dataset, SCV("prefLabel"), Literal("My dataset"))
        ))

        val program = S(prefixes, Seq(inFileStmt), templates)
        logger.info("Autogenerated Tabels program: " + program)
        return program
    }
    
}
