package es.ctic.tabels

import grizzled.slf4j.Logging
import java.io.{File,FileOutputStream,OutputStream,PrintStream}
import org.apache.commons.cli.{Options,PosixParser,CommandLine,HelpFormatter}

object CLI extends Logging {

	val defaultTabelsFilename = "transform.tabels"
	//val defaultDebugOutputFilename = "debug.html"                                                                        
	val currentDirectory = new File(".")
	lazy val recognizedFilesCurrentDirectory : Seq[File] = DataAdapter.findAllRecognizedFilesFromDirectory(currentDirectory)
	
	def main(args: Array[String]) {
	    val options = new Options()
	    options.addOption("t", "tabels_program", true, 
	    	"path to the Tabels program")
	    options.addOption("o", "output_file", true, 
	    	"path to the output RDF file")
	    options.addOption("of", "output_format", true, 
	    	"format to the output RDF file (N3, TTL, RDF/XML). Default output format is RDF/XML")
	    options.addOption("d", "debug_html_file", true, 
	    	"path to the debug HTML output file")
	    val cliParser = new PosixParser();
		try {
            val cmd : CommandLine = cliParser.parse(options, args)

            val spreadsheetFiles : Seq[File] = if (cmd.getArgs isEmpty) recognizedFilesCurrentDirectory else cmd.getArgs.map(new File(_))
			if (spreadsheetFiles.isEmpty) throw new NoInputFiles()
			val dataSource : DataSource = new DataAdaptersDelegate(spreadsheetFiles, Some(currentDirectory))
			logger.debug("Processing these input files: " + dataSource.filenames)
			
			logger.debug("Parsing Tabels program")
            val tabelsFilename = if (cmd hasOption "t") cmd.getOptionValue("t") else defaultTabelsFilename
			val parser = new TabelsParser()
			var autogenerator = new BasicAutogenerator()
            val programFile = new File(tabelsFilename)
            val program = if (programFile.exists()) { parser.parseProgram(programFile) } else autogenerator.autogenerateProgram(dataSource)

		    val prettyPrinter = new PrettyPrint()
		    program.accept(prettyPrinter)
			logger.debug("Interpreting AST: " + prettyPrinter.toString)
			val interpreter : Interpreter = new Interpreter()
			val dataOutput : JenaDataOutput = new JenaDataOutput(program.prefixesAsMap)
			val interpreterTrace = interpreter.interpret(program, dataSource, dataOutput)
			
			if (cmd hasOption "d") {
			    val debugFile = cmd.getOptionValue("d")
			    val dos = new PrintStream(new FileOutputStream(debugFile))
			    new Debugger().serializeInterpreterTrace(interpreterTrace, dos)
			    dos.close()
			}
			
			if (programFile.exists() == false) {
			    logger.debug("Writing autogenerated program to file " + tabelsFilename)
			    val tos = new PrintStream(new FileOutputStream(programFile))
			    tos.print(prettyPrinter.toString())
			    tos.close()
		    }
		    val defaultFormat = "RDF/XML"
		    val outputFormat: String = Option(cmd getOptionValue "of").getOrElse(defaultFormat)
		    val possibleValues = Set("RDF/XML", "RDF/XML-ABBREV", "N-TRIPLE", "TURTLE", "TTL", "N3")
		    val outputFormatValidated = outputFormat match {
		    	case validFormat if possibleValues.contains(validFormat) => validFormat
		    	case _ => throw new org.apache.commons.cli.ParseException("wrong format " + outputFormat)
		    }
			logger.debug("Writing output (" + dataOutput.model.size + " triples) in " + outputFormat + " format")
			val os : OutputStream = if (cmd hasOption "o") new FileOutputStream(cmd getOptionValue "o") else System.out
			dataOutput.model.write(os, outputFormatValidated)
			if (cmd hasOption "o") { os.close() }
			System.exit(0)
		} catch {
		    case e : org.apache.commons.cli.ParseException =>
		      System.err.println(e.getMessage)
              new HelpFormatter().printHelp("tabels [OPTIONS] [SPREADSHEET FILES]", options );
              System.exit(1)
		    case e : ParseException =>
		      System.err.println(e.getMessage)
		      System.err.println(e.line)
		      System.err.println(" " * (e.column-1) + "^^")
		      System.exit(2)
		    case e : TabelsException =>
		      logger.error("User error", e)
		      System.err.println(e.getMessage)
		      System.exit(3)
			case e : Exception => 
			  logger.error("Internal error", e)
			  System.exit(4)
		}
	}
}